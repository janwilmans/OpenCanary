#!/usr/bin/env python3
"""Parse compile_commands.json generated by -DCMAKE_EXPORT_COMPILE_COMMANDS=ON to check the completness of the project
"""

import traceback
import sys
import os
import json
import util
from util import sprint, eprint, Priority, report


def get_key(obj, key_name):
    result = []
    if isinstance(obj, dict):
        for key, value in obj.items():
            if key == key_name:
                #print(value)
                result.append(value)
            else:
                result.extend(get_key(value, key_name))
    elif isinstance(obj, list):
        for item in obj:
            result.extend(get_key(item, key_name))
    return result

def get_all_buildable_files(compile_commands):
    result = []
    with open(compile_commands, encoding="utf-8") as file:
        data = json.load(file)
        files = get_key(data, "file")
        for file in files:
            result.append(os.path.normpath(file))
    return result

def is_cpp_file(file):
    return file.endswith(".cc") or file.endswith(".cpp")


def show_usage():
    eprint("  I got arguments:", sys.argv)
    eprint(r"Usage: " + os.path.basename(__file__) + " <compile_commands.json>")
    eprint(r"  <compile_commands.json> file generated by cmake + -DCMAKE_EXPORT_COMPILE_COMMANDS=ON")
    eprint("")


def main():
    if len(sys.argv) < 2:
        eprint(os.path.basename(__file__) + " commandline error: invalid argument(s)\n")
        show_usage()
        sys.exit(1)

    compile_commands = sys.argv[1]
    all_files_in_compile_commands = get_all_buildable_files(compile_commands)
    all_transitive_files = set(util.get_recursive_files_include_tree(all_files_in_compile_commands), set())  
    _headers, cpp_files = util.get_cpp_files_from_directory(".")
    sprint("transitive files:", len(all_transitive_files))

    for file in all_transitive_files:
        sprint(f"Tr: {file}")

    sprint("cpp files:", len(cpp_files))
    for file in cpp_files:
        sprint(f"cpp: {file}")

    for file in cpp_files:
        if "_autogen" in file:
            continue
        if file not in all_transitive_files:
            sprint(file)
            #util.report(Priority.UNSET.value, "", "cmake", file, "cmake_completeness", "CM#1", "build", "C++ source not build", "")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        raise
    except SystemExit:
        raise
    except BrokenPipeError:   # still makes piping into 'head -n' work nicely
        sys.stderr.close()
        sys.exit(0)
    except:
        info = traceback.format_exc()
        eprint(info)
        show_usage()
        sys.exit(1)
