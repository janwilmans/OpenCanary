#!/usr/bin/env python3
""" returns 1 if some files are not clang formatted, else 0
"""

import os, sys, traceback, re
import gitignore_parser, subprocess
from subprocess import Popen, PIPE

# commandline argument used require clang-format-11 or better
CLANG_FMT_BINARY = r"clang-format-11"

def get_lowered_extention(file):
    filename, ext = os.path.splitext(file)
    return ext.lower()


def is_cpp_header(file):
    return get_lowered_extention(file).endswith((".h", ".hpp"))


def is_cpp_source(file):
    return get_lowered_extention(file).endswith((".cpp", ".cc"))


def get_cpp_files_from_directory(path):
    global rootpath
    rootpath = os.path.abspath(path)
    headers = []
    cpps = []

    for root, dirs, files in gitignore_parser.walk(rootpath, filenames=['.gitignore', '.clang-format-ignore']):
        for file in files:
            abs_filename = os.path.abspath(os.path.join(root, file))
            if is_cpp_header(file):
                headers += [abs_filename]
            if is_cpp_source(file):
                cpps += [abs_filename]
    return headers, cpps


def get_cpp_files(files):
    result = []
    for file in files:
        if is_cpp_header(file) or is_cpp_source(file):
            result += [file]
    return result


def is_generated(filename):
    # CMake
    if (re.search("CompilerIdCXX", filename)):
        return True

    with open(filename, encoding='cp437') as f:
        # just check the first 50 lines instead of reading the whole file
        for x in range(50):
            line = f.readline()
            if (re.match("//.*generated include file.", line)):
                return True
            if (re.match("//.*file is autogenerated", line)):
                return True
    return False


def is_clangformatted(file):
    result = subprocess.run([CLANG_FMT_BINARY, "--dry-run", "-Werror", file])
    #print (result)
    return result.returncode == 0


def are_all_formatted(files):
    allFormatted = True
    for f in files:
        if is_generated(f):
            continue
        if not is_clangformatted(f):
            allFormatted = False
    return allFormatted


def run_clangformat(file):
    if is_generated(file):
        return True
    return subprocess.run([CLANG_FMT_BINARY, "-i", file]) == 0


def format_all(files):
    for f in files:
        run_clangformat(f)


def has_argument(option):
    for arg in sys.argv:
        argument = arg.lower().strip()
        if argument == ("/" + option.lower()):
            return True
    return False


def get_files_from_arg_list(args):
    result = []
    for arg in args:
        argument = arg.strip()
        if not argument.startswith("/"):
            result += [argument]
    return result


# run_clang_format.py              # check all C++ files in the working directory recursively
# run_clang_format.py <file1> <file2> <file3> ...         # check specific files
# run_clang_format.py [/f]         # actually format the files inplace instead of only checking, can be added to other options
def main():
    files = get_files_from_arg_list(sys.argv[1:])
    if len(files) < 1:
        headers, cpps = get_cpp_files_from_directory(".")
        files = headers + cpps

    files = get_cpp_files(files)
    if has_argument("f"):
        print("Formatting", len(files), "files...")
        format_all(files)
        print("done.")
        return 0

    print("Checking formatting for", len(files), "files...")
    sys.stdout.flush()
    if are_all_formatted(files):
        print("All files OK\n")
        return 0

    print ("\n" + sys.argv[0] + " returning exitcode 1")
    return 1


if __name__ == "__main__":
    try:
        exit(main())
    except KeyboardInterrupt:
        pass
    except Exception:
        traceback.print_exc(file=sys.stdout)
    sys.exit(1)
